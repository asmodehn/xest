# XestClock Demo

```elixir
Mix.install([
  {:req, "~> 0.3"},
  {:xest_clock, path: "."}
])
```

## Introduction

XestClock is a small library, providing functionality for following a remote clock without spamming it with requests...
The remote clock can indicate a different time, or even tick at a different speed.

XestClock assumes the deviation (skew) of the remote clock is not permanent, and should be equal to 1.0 most of the time. Apart from that, no other assumption is made. The remote time is verified to be monotonic before being taken into account.

However when sending a request for time, the network can delay the packet, the clock might be changing to summer time, etc. but our local clock must always remain as close as possible to the remote time, yet provide a meaningful time indicator (it has to be monotonic to avoid unexpected surprises once a year or so...)

XestClock provides building blocks for the task of simulating an "untrusted clock" locally.

A stream of remote clock ticks can be built and operated on, to extract from it an offset to apply to the current local clock in order to estimate the time at the remote location.

## The remote clock

As an example, let's take a remote clock indicating UTC time

```elixir
remote_unixtime =
  Req.get!("http://worldtimeapi.org/api/timezone/Etc/UTC", cache: false).body["unixtime"]
```

## Time Values and conversion

We can take that value and put it in a structure managing time units conversion

```elixir
v_sec =
  XestClock.Time.Value.new(:second, remote_unixtime)
  |> IO.inspect()
  |> XestClock.Time.Value.convert(:millisecond)
```

## Remote Clock as a Stream

We can then imagine doing this multiple times in a row.
This is a stream of observed ticks of the remote clock.

Note we need to throttle the requests to the server, to avoid meaningless requests.
This means we will also get a local timestamp in the stream.

```elixir
XestClock.Stream.repeatedly_throttled(1000, fn ->
  Req.get!("http://worldtimeapi.org/api/timezone/Etc/UTC", cache: false).body["unixtime"]
end)
|> Stream.map(fn {rv, _local_timestamp} ->
  XestClock.Time.Value.new(:second, rv)
  |> XestClock.Time.Value.convert(:second)
end)
|> Enum.take(2)
```

## Remote Clock Stream with limiter

Now lets put this in a module for reusability.

```elixir
defmodule WorldClock do
  alias XestClock.Time

  def unixtime() do
    IO.inspect("CLOCK REQUEST !")
    Req.get!("http://worldtimeapi.org/api/timezone/Etc/UTC", cache: false).body["unixtime"]
  end

  def stream(unit) do
    XestClock.Stream.repeatedly_throttled(1000, fn ->
      unixtime()
    end)
    |> Elixir.Stream.map(fn {rv, _lts} ->
      Time.Value.new(:second, rv)
      |> Time.Value.convert(unit)
    end)
    |> IO.inspect()
  end
end

# The two first request will be immediate to establish an offset
# The third one will come a bit after...
WorldClock.stream(:second) |> Enum.take(3)
```

## The Server

```elixir

```

## Useful Stream Operators

## The Proxy

## XestClock API
