# XestClock Demo

```elixir
Mix.install([
  {:req, "~> 0.3"},
  {:xest_clock, path: "."},
  {:vega_lite, "~> 0.1.6"},
  {:kino_vega_lite, "~> 0.1.7"}
])

alias VegaLite, as: Vl
```

## Introduction

XestClock is a small library, providing functionality for following a remote clock without spamming it with requests...
The remote clock can indicate a different time, or even tick at a different speed.

XestClock assumes the deviation (skew) of the remote clock is not permanent, and should be equal to 1.0 most of the time. Apart from that, no other assumption is made. The remote time is verified to be monotonic before being taken into account.

However when sending a request for time, the network can delay the packet, the clock might be changing to summer time, etc. but our local clock must always remain as close as possible to the remote time, yet provide a meaningful time indicator (it has to be monotonic to avoid unexpected surprises once a year or so...)

XestClock provides building blocks for the task of simulating an "untrusted clock" locally.

A stream of remote clock ticks can be built and operated on, to extract from it an offset to apply to the current local clock in order to estimate the time at the remote location.

## The remote clock

As an example, let's take a remote clock indicating UTC time

```elixir
remote_unixtime =
  Req.get!("http://worldtimeapi.org/api/timezone/Etc/UTC", cache: false).body["unixtime"]
```

## Time Values and conversion

We can take that value and put it in a structure managing time units conversion

```elixir
v_sec =
  XestClock.Time.Value.new(:second, remote_unixtime)
  |> IO.inspect()
  |> XestClock.Time.Value.convert(:millisecond)
```

## Remote Clock as a Stream

We can then imagine doing this multiple times in a row.
This is a stream of observed ticks of the remote clock.

Note: we need to **throttle the requests** to the server, to avoid meaningless traffic.
This means we will also get a local timestamp in the stream, which we can ignore on the next stream operator.

```elixir
XestClock.Stream.repeatedly_throttled(1000, fn ->
  Req.get!("http://worldtimeapi.org/api/timezone/Etc/UTC", cache: false).body["unixtime"]
end)
|> Stream.map(fn {rv, local_timestamp} ->
  # only display the timestamp
  IO.inspect(local_timestamp)

  XestClock.Time.Value.new(:second, rv)
  |> XestClock.Time.Value.convert(:second)
end)
|> Enum.take(2)
```

## Remote Clock Stream with limiter

If we put this in a module, we can now simply access the remote clock via a stream of successive ticks.

```elixir
defmodule WorldClock do
  alias XestClock.Time

  def unixtime() do
    IO.inspect("CLOCK REQUEST !")
    Req.get!("http://worldtimeapi.org/api/timezone/Etc/UTC", cache: false).body["unixtime"]
  end

  def stream(unit) do
    XestClock.Stream.repeatedly_throttled(1000, fn ->
      unixtime()
    end)
    |> Elixir.Stream.map(fn {rv, _lts} ->
      Time.Value.new(:second, rv)
      |> Time.Value.convert(unit)
    end)
    |> IO.inspect()
  end
end

# The two first request will be immediate to establish an offset
# The third one will come a bit after...
WorldClock.stream(:second) |> Enum.take(3)
```

## The Server

We can now build a local "image" of the remote clock, with `XestClock.Server`.
This allow us to simulate a clock locally.

Notice how `XestClock.Server` provides the monotonic_time/2 impure function to retrieve the time.

```elixir
defmodule WorldClockProxy do
  use XestClock.Server

  # Client Code
  @impl true
  def start_link(unit, opts \\ []) when is_list(opts) do
    XestClock.Server.start_link(__MODULE__, unit, opts)
  end

  @impl true
  def init(state) do
    XestClock.Server.init(state, &handle_remote_unix_time/1)
  end

  def monotonic_time(pid \\ __MODULE__, unit) do
    XestClock.Server.monotonic_time(pid, unit)
  end

  @impl true
  def ticks(pid \\ __MODULE__, demand) do
    XestClock.Server.ticks(pid, demand)
  end

  @impl true
  def handle_remote_unix_time(unit) do
    XestClock.Time.Value.new(:second, WorldClock.unixtime())
    # we need to convert to whatever unit is expected in stream
    |> XestClock.Time.Value.convert(unit)
    |> IO.inspect()
  end
end

# a server that tracks a remote clock internally in seconds
{:ok, spid} = WorldClockProxy.start_link(:second)
```

a one time call, asking for a remote time (estimated) in millisecond

```elixir
# a one time call, asking for a remote time (estimated) in millisecond
WorldClockProxy.monotonic_time(spid, :millisecond)
```

we can also ask an estimation for the error. However at first it is a bit rough

```elixir
XestClock.Server.error(spid, :millisecond)
```

When we have more ticks, we can compute the skew of the remote clock,
and we get a more refined estimation for the error.

Feel free to evaluate this cell multiple time, until error is not zero:

```elixir
# a one time call, asking for a remote time (estimated) in millisecond
WorldClockProxy.monotonic_time(spid, :millisecond)
XestClock.Server.error(spid, :millisecond)
```

## Let's see it in action !

Kino TODO

```elixir
chart =
  Vl.new(width: 800, height: 400)
  |> Vl.mark(:line)
  |> Vl.encode_field(:x, "x", type: :quantitative)
  |> Vl.encode_field(:y, "y", type: :quantitative)
  |> Kino.VegaLite.new()
  |> Kino.render()

for i <- 1..300 do
  point = %{x: i / 10, y: :math.sin(i / 10)}
  Kino.VegaLite.push(chart, point)
  Process.sleep(25)
end
```

## Useful Stream Operators

## XestClock API
