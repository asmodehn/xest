# XestClock Demo

```elixir
Mix.install([
  {:req, "~> 0.3"},
  {:xest_clock, path: "."},
  {:vega_lite, "~> 0.1.6"},
  {:kino_vega_lite, "~> 0.1.7"}
])

alias VegaLite, as: Vl
```

## Introduction

XestClock is a small library, providing functionality for following a remote clock without spamming it with requests...
The remote clock can indicate a different time, or even tick at a different speed.

XestClock assumes the deviation (skew) of the remote clock is not permanent, and should be equal to 1.0 most of the time. Apart from that, no other assumption is made. The remote time is verified to be monotonic before being taken into account.

However when sending a request for time, the network can delay the packet, the clock might be changing to summer time, etc. but our local clock must always remain as close as possible to the remote time, yet provide a meaningful time indicator (it has to be monotonic to avoid unexpected surprises once a year or so...)

XestClock provides building blocks for the task of simulating an "untrusted clock" locally.

A stream of remote clock ticks can be built and operated on, to extract from it an offset to apply to the current local clock in order to estimate the time at the remote location.

## The remote clock

As an example, let's take a remote clock indicating UTC time

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
remote_unixtime =
  Req.get!("http://worldtimeapi.org/api/timezone/Etc/UTC", cache: false).body["unixtime"]

# If changes to ascii:
# |> String.split("\n")
# |> Enum.map(&String.split(&1, ": "))
# |> Map.new(&List.to_tuple/1)
# |> Map.get("unixtime")
# |> String.to_integer()
```

## Time Values and conversion

We can take that value and put it in a structure managing time units conversion

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
v_sec =
  XestClock.Time.Value.new(:second, remote_unixtime)
  |> IO.inspect()
  |> XestClock.Time.Value.convert(:millisecond)
```

## Remote Clock as a Stream

We can then imagine doing this multiple times in a row.
This is a stream of observed ticks of the remote clock.

Note: we need to **throttle the requests** to the server, to avoid meaningless traffic.
This means we will also get a local timestamp in the stream, which we can ignore on the next stream operator.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
XestClock.Stream.repeatedly_throttled(1000, fn ->
  Req.get!("http://worldtimeapi.org/api/timezone/Etc/UTC", cache: false).body["unixtime"]
  # |> String.split("\n")
  # |> Enum.map(&String.split(&1, ": "))
  # |> Map.new(&List.to_tuple/1)
  # |> Map.get("unixtime")
  # |> String.to_integer()
end)
|> Stream.map(fn {rv, local_timestamp} ->
  # only display the timestamp
  IO.inspect(local_timestamp)

  XestClock.Time.Value.new(:second, rv)
  |> XestClock.Time.Value.convert(:second)
end)
|> Enum.take(2)
```

## Remote Clock Stream with limiter

If we put this in a module, we can now simply access the remote clock via a stream of successive ticks.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule WorldClock do
  alias XestClock.Time

  def unixtime() do
    IO.inspect("CLOCK REQUEST !")
    Req.get!("http://worldtimeapi.org/api/timezone/Etc/UTC", cache: false).body["unixtime"]
    # |> String.split("\n")
    # |> Enum.map(&String.split(&1, ": "))
    # |> Map.new(&List.to_tuple/1)
    # |> Map.get("unixtime")
    # |> String.to_integer()
  end

  def stream(unit) do
    XestClock.Stream.repeatedly_throttled(1000, fn ->
      unixtime()
    end)
    |> Elixir.Stream.map(fn {rv, _lts} ->
      Time.Value.new(:second, rv)
      |> Time.Value.convert(unit)
    end)
    |> IO.inspect()
  end
end

WorldClock.stream(:second) |> Enum.take(3)
```

## The Server

We can now build a local "image" of the remote clock, with `XestClock.Server`.
This allow us to simulate a clock locally.

Notice how `XestClock.Server` provides the `monotonic_time/2` impure function to retrieve the time.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule WorldClockProxy do
  use XestClock.Server

  # Client Code
  @impl true
  def start_link(unit, opts \\ []) when is_list(opts) do
    XestClock.Server.start_link(__MODULE__, unit, opts)
  end

  @impl true
  def init(state) do
    XestClock.Server.init(state, &handle_remote_unix_time/1)
  end

  def monotonic_time(pid \\ __MODULE__, unit) do
    XestClock.Server.monotonic_time(pid, unit)
  end

  @impl true
  def ticks(pid \\ __MODULE__, demand) do
    XestClock.Server.ticks(pid, demand)
  end

  @impl true
  def handle_remote_unix_time(unit) do
    XestClock.Time.Value.new(:second, WorldClock.unixtime())
    # we need to convert to whatever unit is expected in stream
    |> XestClock.Time.Value.convert(unit)
    |> IO.inspect()
  end
end

# a server that tracks a remote clock internally in milliseconds
{:ok, spid} = WorldClockProxy.start_link(:millisecond)
```

a one time call, asking for a remote time (estimated) in `:millisecond`.
However, since the server time is in second, we clearly can see the millisecond precision estimated from local clock.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# a one time call, asking for a remote time (estimated) in millisecond
WorldClockProxy.monotonic_time(spid, :millisecond)
```

we can also ask an estimation for the error. However at first we can only get a simple offset.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
XestClock.Server.error(spid)
```

When we have more ticks, we can compute the skew of the remote clock,
and we get a more refined estimation for the error.

Feel free to evaluate this cell multiple time if needed, skew should not be zero, since `:millisecond` precision of the proxy genserver is not reachable on a remote clock over internet.

Notice how the estimated error increase, until a next request is deemed necessary.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# a one time call, asking for a remote time (estimated) in millisecond
WorldClockProxy.monotonic_time(spid, :second)
XestClock.Server.error(spid)
```

## Let's see it in action !

First lets get the simulated clock and plot it against the local time.
It should be almost linear.

Note that a request to the remote clock is done only when needed, and that the time remains (weakly) monotonic: the same value is reuse, but it doesn't "go back".

```elixir
chart =
  Vl.new(width: 800, height: 400)
  |> Vl.mark(:line)
  |> Vl.encode_field(:x, "x", type: :quantitative)
  |> Vl.encode_field(:y, "y", type: :quantitative)
  |> Kino.VegaLite.new()
  |> Kino.render()

local_start = XestClock.Stream.Timed.LocalStamp.now(:second)
remote_start = WorldClockProxy.monotonic_time(spid, :second) |> IO.inspect()

for _ <- 1..30 do
  # This will emulate remote time and if necessary do a remote call
  mono_time = WorldClockProxy.monotonic_time(spid, :second) |> IO.inspect()

  now = XestClock.Stream.Timed.LocalStamp.now(:second)

  # Note x is only local measurement of time (nothing remote)
  # Only y measure of error, is the difference in offset between remote estimation and local value
  point = %{x: now.monotonic.value - local_start.monotonic.value, y: mono_time - remote_start}
  Kino.VegaLite.push(chart, point)
  :ok = Process.sleep(1000)
end
```

Second, let's see what we can see if we plot only the offset when we force a request at each local second (simulating the worst case)...
This should still be fine and not pathological behaviour, as web services usually support such rate.

```elixir
chart =
  Vl.new(width: 800, height: 400)
  |> Vl.mark(:line)
  |> Vl.encode_field(:x, "x", type: :quantitative)
  |> Vl.encode_field(:y, "y", type: :quantitative)
  |> Kino.VegaLite.new()
  |> Kino.render()

local_start = XestClock.Stream.Timed.LocalStamp.now(:second)
{_error_start, delta_start} = XestClock.Server.error(spid)

for _ <- 1..60 do
  # This will do a remote call
  {_ts, _lts, _ldt} = List.first(WorldClockProxy.ticks(spid, 1))

  # we want to watch the current error on the server with millisecond precision !
  {_error, delta} = XestClock.Server.error(spid)

  # lets take now with a second precision to measure elasped time.
  now = XestClock.Stream.Timed.LocalStamp.now(:second)

  # Note x is only local measurement of time (nothing remote)
  # Only y measure of error, is the difference in offset between remote estimation and local value
  point = %{
    x: now.monotonic.value - local_start.monotonic.value,
    y: delta.offset.value - delta_start.offset.value
  }

  Kino.VegaLite.push(chart, point)
  :ok = Process.sleep(1000)
end
```

We can build a quick diagram of the estimation errors for the proxy clock.

Note since we aim to reach milliseconds precision but we cannot, it is possible the proxy server times out (waiting for a throttled request on the remote server)

=> TODO : workaround ? properfix ?

```elixir
chart =
  Vl.new(width: 800, height: 400)
  |> Vl.mark(:line)
  |> Vl.encode_field(:x, "x", type: :quantitative)
  |> Vl.encode_field(:y, "y", type: :quantitative)
  |> Kino.VegaLite.new()
  |> Kino.render()

local_start = XestClock.Stream.Timed.LocalStamp.now(:second)

for _ <- 1..30 do
  # This will emulate remote time and if necessary do a remote call
  # Since the millisecond precision is almost impossible to reach via a network.
  _mono_time = WorldClockProxy.monotonic_time(spid, :millisecond)

  # we want to watch the current error on the server
  {error, _delta} = XestClock.Server.error(spid)
  now = XestClock.Stream.Timed.LocalStamp.now(:second)

  # Note x is only local measurement of time (nothing remote)
  # Only y measure of error, is the difference in offset between remote estimation and local value
  point = %{x: now.monotonic.value - local_start.monotonic.value, y: error.value}
  Kino.VegaLite.push(chart, point)
  :ok = Process.sleep(1000)
end
```

## Useful Stream Operators

## XestClock API
