defmodule XestClock.Stream do
  # hiding Elixir.System to make sure we do not inadvertently use it
  alias XestClock.System
  # hiding Elixir.System to make sure we do not inadvertently use it
  alias XestClock.Process

  @moduledoc """
      A module holding stream operators similar to Elixir's but with some extra  stuff
  """

  alias XestClock.Stream.Timed

  alias XestClock.Time

  @doc """
  A Monotonously increasing stream. Replace values that would invalidate the monotonicity
  with a duplicate of the previous value.
  Use Stream.dedup/1 if you want unique values, ie. a strictly monotonous stream.

  iex> m = XestClock.Stream.Monotone.increasing([1,3,2,5,4])
  iex(1)> Enum.to_list(m)
  [1,3,3,5,5]
  iex(2)> m |> Stream.dedup() |> Enum.to_list()
  [1,3,5]

  Note: it works also if local timestamps are part of the element, it will just ignore them.
  """
  @spec monotone_increasing(Enumerable.t()) :: Enumerable.t()
  def monotone_increasing(enum) do
    Stream.transform(enum, nil, fn
      {i, %Timed.LocalStamp{} = ts}, nil -> {[{i, ts}], i}
      i, nil -> {[i], i}
      {i, %Timed.LocalStamp{} = ts}, acc -> if acc <= i, do: {[{i, ts}], i}, else: {[acc], acc}
      i, acc -> if acc <= i, do: {[i], i}, else: {[acc], acc}
    end)
  end

  @doc """
  A Monotonously decreasing stream. Replace values that would invalidate the monotonicity
  with a duplicate of the previous value.
  Use Stream.dedup/1 if you want unique value, ie. a strictly monotonous stream.

  iex> m = XestClock.Stream.Monotone.decreasing([4,5,2,3,1])
  iex(1)> Enum.to_list(m)
  [4,4,2,2,1]
  iex(2)> m |> Stream.dedup() |> Enum.to_list()
  [4,2,1]

  Note: it works also if local timestamps are part of the element, it will just ignore them.
  """
  @spec monotone_decreasing(Enumerable.t()) :: Enumerable.t()
  def monotone_decreasing(enum) do
    Stream.transform(enum, nil, fn
      {i, %Timed.LocalStamp{} = ts}, nil -> {[{i, ts}], i}
      i, nil -> {[i], i}
      {i, %Timed.LocalStamp{} = ts}, acc -> if acc >= i, do: {[{i, ts}], i}, else: {[acc], acc}
      i, acc -> if acc >= i, do: {[i], i}, else: {[acc], acc}
    end)
  end

  @doc """
  Returns a stream generated by calling `generator_fun` repeatedly.

    This extends Elixir's Stream.repeatedly by adding a timestamp to each element of the stream
  """
  @spec repeatedly_timed(System.time_unit(), (() -> Stream.element())) :: Enumerable.t()
  def repeatedly_timed(precision, generator_fun) when is_function(generator_fun, 0) do
    &do_repeatedly_timed(precision, generator_fun, &1, &2)
  end

  defp do_repeatedly_timed(precision, generator_fun, {:suspend, acc}, fun) do
    {:suspended, acc, &do_repeatedly_timed(precision, generator_fun, &1, fun)}
  end

  defp do_repeatedly_timed(_precision, _generator_fun, {:halt, acc}, _fun) do
    {:halted, acc}
  end

  defp do_repeatedly_timed(precision, generator_fun, {:cont, acc}, fun) do
    now = Timed.LocalStamp.now(precision)

    do_repeatedly_timed(precision, generator_fun, fun.({generator_fun.(), now}, acc), fun)
  end

  @doc """
  Returns a stream generated by calling `generator_fun` repeatedly.

    This extends Elixir's Stream.repeatedly by adding a timestamp to each element of the stream,
    and ensuring successive calls to the function respect a minimal cooldown period.

  WARNING : this will make your current process sleep. Remember to only call it in a genserver.
  """

  @spec repeatedly_throttled(Time.Value.t(), (() -> Stream.element())) :: Enumerable.t()
  def repeatedly_throttled(%Time.Value{} = min_period, generator_fun)
      when is_function(generator_fun, 0) do
    repeatedly_throttled(Time.Value.convert(min_period, :millisecond).value, generator_fun)
  end

  # TODO : a debug flag to print something when sleeping...
  @spec repeatedly_throttled(integer, (() -> Stream.element())) :: Enumerable.t()
  def repeatedly_throttled(min_period_ms, generator_fun)
      when is_integer(min_period_ms) and is_function(generator_fun, 0) do
    &do_repeatedly_throttled(
      {
        min_period_ms,
        # no timestamp taken yet
        nil
      },
      generator_fun,
      &1,
      &2
    )
  end

  defp do_repeatedly_throttled({min_period_ms, lts}, generator_fun, {:suspend, acc}, fun) do
    {:suspended, acc, &do_repeatedly_throttled({min_period_ms, lts}, generator_fun, &1, fun)}
  end

  defp do_repeatedly_throttled({_min_period_ms, _lts}, _generator_fun, {:halt, acc}, _fun) do
    {:halted, acc}
  end

  # First time : cannot be throttled until we have a previous timestamp
  # in do_repeatedly_throttled own accumulator in the first arg
  defp do_repeatedly_throttled({min_period_ms, nil}, generator_fun, {:cont, acc}, fun) do
    # Note : min_period_ms is supposed to be in millisecond.
    # no point to be more precise here.
    now = Timed.LocalStamp.now(:millisecond)

    do_repeatedly_throttled(
      {min_period_ms, now},
      generator_fun,
      fun.({generator_fun.(), now}, acc),
      fun
    )
  end

  defp do_repeatedly_throttled({min_period_ms, lts}, generator_fun, {:cont, acc}, fun) do
    # Note : min_period_ms is supposed to be in millisecond.
    # no point to be more precise here.
    now = Timed.LocalStamp.now(:millisecond)

    # offset difference
    current_offset = Time.Value.diff(now.monotonic, lts.monotonic)

    # if the current time is far enough from previous ts
    to_wait = min_period_ms - current_offset.value
    # timeout always in milliseconds !

    #    IO.inspect("to_wait: #{to_wait}")

    now_again =
      if to_wait > 0 do
        # SIDE_EFFECT !
        Process.sleep(to_wait)
        Timed.LocalStamp.now(:millisecond)
      else
        now
      end

    do_repeatedly_throttled(
      {min_period_ms, now_again},
      generator_fun,
      fun.({generator_fun.(), now_again}, acc),
      fun
    )
  end
end
