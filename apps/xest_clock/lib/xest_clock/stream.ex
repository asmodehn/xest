defmodule XestClock.Stream do
  @moduledoc """
      A module holding stream operators similar to Elixir's but with some extra  stuff
  """

  alias XestClock.Stream.Timed

  alias XestClock.Time

  @doc """
  A Monotonously increasing stream. Replace values that would invalidate the monotonicity
  with a duplicate of the previous value.
  Use Stream.dedup/1 if you want unique values, ie. a strictly monotonous stream.

  iex> m = XestClock.Stream.Monotone.increasing([1,3,2,5,4])
  iex(1)> Enum.to_list(m)
  [1,3,3,5,5]
  iex(2)> m |> Stream.dedup() |> Enum.to_list()
  [1,3,5]

  Note: it works also if local timestamps are part of the element, it will just ignore them.
  """
  @spec monotone_increasing(Enumerable.t()) :: Enumerable.t()
  def monotone_increasing(enum) do
    Stream.transform(enum, nil, fn
      {i, %Timed.LocalStamp{} = ts}, nil -> {[{i, ts}], i}
      i, nil -> {[i], i}
      {i, %Timed.LocalStamp{} = ts}, acc -> if acc <= i, do: {[{i, ts}], i}, else: {[acc], acc}
      i, acc -> if acc <= i, do: {[i], i}, else: {[acc], acc}
    end)
  end

  @doc """
  A Monotonously decreasing stream. Replace values that would invalidate the monotonicity
  with a duplicate of the previous value.
  Use Stream.dedup/1 if you want unique value, ie. a strictly monotonous stream.

  iex> m = XestClock.Stream.Monotone.decreasing([4,5,2,3,1])
  iex(1)> Enum.to_list(m)
  [4,4,2,2,1]
  iex(2)> m |> Stream.dedup() |> Enum.to_list()
  [4,2,1]

  Note: it works also if local timestamps are part of the element, it will just ignore them.
  """
  @spec monotone_decreasing(Enumerable.t()) :: Enumerable.t()
  def monotone_decreasing(enum) do
    Stream.transform(enum, nil, fn
      {i, %Timed.LocalStamp{} = ts}, nil -> {[{i, ts}], i}
      i, nil -> {[i], i}
      {i, %Timed.LocalStamp{} = ts}, acc -> if acc >= i, do: {[{i, ts}], i}, else: {[acc], acc}
      i, acc -> if acc >= i, do: {[i], i}, else: {[acc], acc}
    end)
  end

  @doc """
  Returns a stream generated by calling `generator_fun` repeatedly.

    This extends Elixir's Stream.repeatedly by adding a timestamp to each element of the stream
  """
  @spec repeatedly_timed((() -> Stream.element())) :: Enumerable.t()
  def repeatedly_timed(generator_fun) when is_function(generator_fun, 0) do
    &do_repeatedly_timed(generator_fun, &1, &2)
  end

  # TODO :get rid of precision here, lets use native precision for local timestamps.

  defp do_repeatedly_timed(generator_fun, {:suspend, acc}, fun) do
    {:suspended, acc, &do_repeatedly_timed(generator_fun, &1, fun)}
  end

  defp do_repeatedly_timed(_generator_fun, {:halt, acc}, _fun) do
    {:halted, acc}
  end

  defp do_repeatedly_timed(generator_fun, {:cont, acc}, fun) do
    bef = Timed.LocalStamp.now()
    result = generator_fun.()
    aft = Timed.LocalStamp.now()

    do_repeatedly_timed(
      generator_fun,
      fun.(
        {
          result,
          Timed.LocalStamp.middle_stamp_estimate(bef, aft)
        },
        acc
      ),
      fun
    )
  end

  @doc """
  Returns a stream generated by calling `generator_fun` repeatedly.

    This extends Elixir's Stream.repeatedly by adding a timestamp to each element of the stream,
    and ensuring successive calls to the function respect a minimal cooldown period.

  WARNING : this will make your current process sleep. Remember to only call it in a genserver.
  """

  @spec repeatedly_throttled(Time.Value.t(), (() -> Stream.element())) :: Enumerable.t()
  def repeatedly_throttled(%Time.Value{} = min_period, generator_fun)
      when is_function(generator_fun, 0) do
    repeatedly_throttled(Time.Value.convert(min_period, :millisecond).value, generator_fun)
  end

  @spec repeatedly_throttled(atom(), (() -> Stream.element())) :: Enumerable.t()
  def repeatedly_throttled(min_period, generator_fun)
      when is_atom(min_period) and is_function(generator_fun, 0) do
    case min_period do
      :second -> repeatedly_throttled(1_000, generator_fun)
      :millisecond -> repeatedly_throttled(1, generator_fun)
      # support time_unit atoms, but doesn't throttle (no point since sleep() precision is 1 ms)
      :microsecond -> repeatedly_timed(generator_fun)
      :nanosecond -> repeatedly_timed(generator_fun)
    end
  end

  # TODO : semantics of interger (part paer second like in time_unit, or direct implicit ms meaning ?

  # TODO : a debug flag to print something when sleeping...
  @spec repeatedly_throttled(integer, (() -> Stream.element())) :: Enumerable.t()
  def repeatedly_throttled(min_period_ms, generator_fun)
      when is_integer(min_period_ms) and is_function(generator_fun, 0) do
    &do_repeatedly_throttled(
      {
        min_period_ms,
        # no timestamp taken yet
        nil
      },
      generator_fun,
      &1,
      &2
    )
  end

  defp do_repeatedly_throttled({min_period_ms, lts}, generator_fun, {:suspend, acc}, fun) do
    {:suspended, acc, &do_repeatedly_throttled({min_period_ms, lts}, generator_fun, &1, fun)}
  end

  defp do_repeatedly_throttled({_min_period_ms, _lts}, _generator_fun, {:halt, acc}, _fun) do
    {:halted, acc}
  end

  # First time : cannot be throttled until we have a previous timestamp
  # in do_repeatedly_throttled own accumulator in the first arg
  defp do_repeatedly_throttled({min_period_ms, nil}, generator_fun, {:cont, acc}, fun) do
    # Note : min_period_ms is supposed to be in millisecond.

    bef = Timed.LocalStamp.now()
    result = generator_fun.()
    aft = Timed.LocalStamp.now()

    do_repeatedly_throttled(
      {min_period_ms, aft},
      generator_fun,
      fun.(
        {
          result,
          Timed.LocalStamp.middle_stamp_estimate(bef, aft)
        },
        acc
      ),
      fun
    )
  end

  defp do_repeatedly_throttled({min_period_ms, lts}, generator_fun, {:cont, acc}, fun) do
    # Note : min_period_ms is supposed to be in millisecond.

    then = lts |> Timed.LocalStamp.after_a_while(Time.Value.new(:millisecond, min_period_ms))

    # CAREFUL: this might sleep for a little while...
    bef = Timed.LocalStamp.wake_up_at(then)

    result = generator_fun.()

    aft = Timed.LocalStamp.now()

    do_repeatedly_throttled(
      {min_period_ms, aft},
      generator_fun,
      fun.(
        {
          result,
          Timed.LocalStamp.middle_stamp_estimate(bef, aft)
        },
        acc
      ),
      fun
    )
  end
end
